// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64

package ebpf

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

// loadRdmaTracing returns the embedded CollectionSpec for rdmaTracing.
func loadRdmaTracing() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_RdmaTracingBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load rdmaTracing: %w", err)
	}

	return spec, err
}

// loadRdmaTracingObjects loads rdmaTracing and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*rdmaTracingObjects
//	*rdmaTracingPrograms
//	*rdmaTracingMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadRdmaTracingObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadRdmaTracing()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// rdmaTracingSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type rdmaTracingSpecs struct {
	rdmaTracingProgramSpecs
	rdmaTracingMapSpecs
	rdmaTracingVariableSpecs
}

// rdmaTracingProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type rdmaTracingProgramSpecs struct {
	TraceCreateQp  *ebpf.ProgramSpec `ebpf:"trace_create_qp"`
	TraceDestroyQp *ebpf.ProgramSpec `ebpf:"trace_destroy_qp"`
	TraceModifyQp  *ebpf.ProgramSpec `ebpf:"trace_modify_qp"`
}

// rdmaTracingMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type rdmaTracingMapSpecs struct {
	RdmaEvents *ebpf.MapSpec `ebpf:"rdma_events"`
}

// rdmaTracingVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type rdmaTracingVariableSpecs struct {
}

// rdmaTracingObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadRdmaTracingObjects or ebpf.CollectionSpec.LoadAndAssign.
type rdmaTracingObjects struct {
	rdmaTracingPrograms
	rdmaTracingMaps
	rdmaTracingVariables
}

func (o *rdmaTracingObjects) Close() error {
	return _RdmaTracingClose(
		&o.rdmaTracingPrograms,
		&o.rdmaTracingMaps,
	)
}

// rdmaTracingMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadRdmaTracingObjects or ebpf.CollectionSpec.LoadAndAssign.
type rdmaTracingMaps struct {
	RdmaEvents *ebpf.Map `ebpf:"rdma_events"`
}

func (m *rdmaTracingMaps) Close() error {
	return _RdmaTracingClose(
		m.RdmaEvents,
	)
}

// rdmaTracingVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadRdmaTracingObjects or ebpf.CollectionSpec.LoadAndAssign.
type rdmaTracingVariables struct {
}

// rdmaTracingPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadRdmaTracingObjects or ebpf.CollectionSpec.LoadAndAssign.
type rdmaTracingPrograms struct {
	TraceCreateQp  *ebpf.Program `ebpf:"trace_create_qp"`
	TraceDestroyQp *ebpf.Program `ebpf:"trace_destroy_qp"`
	TraceModifyQp  *ebpf.Program `ebpf:"trace_modify_qp"`
}

func (p *rdmaTracingPrograms) Close() error {
	return _RdmaTracingClose(
		p.TraceCreateQp,
		p.TraceDestroyQp,
		p.TraceModifyQp,
	)
}

func _RdmaTracingClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed rdmatracing_x86_bpfel.o
var _RdmaTracingBytes []byte
