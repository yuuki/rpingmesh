// Package ebpf provides eBPF functionality for monitoring RDMA connections.
package ebpf

//go:generate bpf2go -cc clang -cflags "-O2 -g -Wall -Werror" -target amd64 rdmaTracing bpf/rdma_tracing.c -- -I./bpf/include -I/usr/include -I/usr/include/linux/bpf -I/usr/include/x86_64-linux-gnu

import (
	"bytes"
	"context"
	"embed"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
)

//go:embed bpf/*
var bpfFS embed.FS

// RdmaConnTuple represents RDMA connection 5-tuple information
type RdmaConnTuple struct {
	Timestamp uint64   // Timestamp when the event occurred (nanoseconds)
	EventType uint8    // Event type (1: create, 2: modify, 3: destroy)
	SrcQPN    uint32   // Source Queue Pair Number
	DstQPN    uint32   // Destination Queue Pair Number
	SrcGID    [16]byte // Source Global Identifier (GID)
	DstGID    [16]byte // Destination Global Identifier (GID)
	QPState   int32    // QP state (valid only for modify_qp)
	PID       uint32   // Process ID
	TID       uint32   // Thread ID
	Comm      [16]byte // Process name
}

// EventTypeString returns the string representation of the event type
func (t *RdmaConnTuple) EventTypeString() string {
	switch t.EventType {
	case 1:
		return "CREATE"
	case 2:
		return "MODIFY"
	case 3:
		return "DESTROY"
	default:
		return "UNKNOWN"
	}
}

// SrcGIDString returns the string representation of SrcGID
func (t *RdmaConnTuple) SrcGIDString() string {
	return hex.EncodeToString(t.SrcGID[:])
}

// DstGIDString returns the string representation of DstGID
func (t *RdmaConnTuple) DstGIDString() string {
	return hex.EncodeToString(t.DstGID[:])
}

// String returns a human-readable representation of RdmaConnTuple
func (t *RdmaConnTuple) String() string {
	return fmt.Sprintf(
		"Event: %s, Time: %s, Src QPN: %d, Dst QPN: %d, Src GID: %s, Dst GID: %s, QP State: %d, PID: %d, Comm: %s",
		t.EventTypeString(),
		time.Unix(0, int64(t.Timestamp)),
		t.SrcQPN,
		t.DstQPN,
		t.SrcGIDString(),
		t.DstGIDString(),
		t.QPState,
		t.PID,
		string(bytes.TrimRight(t.Comm[:], "\x00")),
	)
}

// ServiceTracer manages the eBPF program for tracing RDMA connections
type ServiceTracer struct {
	objs    rdmaTracingObjects
	kprobes []link.Link
	reader  *ringbuf.Reader
	eventCh chan RdmaConnTuple
	stopCh  chan struct{}
}

// rdmaTracingObjects is a type generated by the cilium/ebpf library
// to load eBPF objects
type rdmaTracingObjects struct {
	RdmaEvents *ebpf.Map `ebpf:"rdma_events"`

	// kprobe points
	TraceModifyQp  *ebpf.Program `ebpf:"trace_modify_qp"`
	TraceDestroyQp *ebpf.Program `ebpf:"trace_destroy_qp"`
	TraceCreateQp  *ebpf.Program `ebpf:"trace_create_qp"`
}

// NewServiceTracer creates a new ServiceTracer instance
func NewServiceTracer() (*ServiceTracer, error) {
	// Remove kernel memory lock limit
	if err := rlimit.RemoveMemlock(); err != nil {
		return nil, fmt.Errorf("removing memlock rlimit: %w", err)
	}

	// Options for compiling eBPF program
	opts := ebpf.CollectionOptions{
		Programs: ebpf.ProgramOptions{
			LogSize: 2 * 1024 * 1024, // 2MB
		},
	}

	// Compile and load eBPF program
	var objs rdmaTracingObjects
	if err := loadRdmaTracingObjects(&objs, &opts); err != nil {
		var logErr error
		if opts.Programs.LogSize > 0 {
			// Output detailed error if logging is enabled
			logErr = fmt.Errorf("%w: %s", err, opts.Programs.LogBuf)
		} else {
			logErr = fmt.Errorf("%w", err)
		}
		return nil, fmt.Errorf("loading objects: %w", logErr)
	}

	// Initialize channels
	eventCh := make(chan RdmaConnTuple, 100)
	stopCh := make(chan struct{})

	return &ServiceTracer{
		objs:    objs,
		eventCh: eventCh,
		stopCh:  stopCh,
	}, nil
}

// Start begins tracing
func (t *ServiceTracer) Start() error {
	var err error
	var kprobes []link.Link

	// Attach kprobes
	kp, err := link.Kprobe("ib_modify_qp", t.objs.TraceModifyQp, nil)
	if err != nil {
		return fmt.Errorf("attaching kprobe to ib_modify_qp: %w", err)
	}
	kprobes = append(kprobes, kp)

	kp, err = link.Kprobe("ib_destroy_qp", t.objs.TraceDestroyQp, nil)
	if err != nil {
		return fmt.Errorf("attaching kprobe to ib_destroy_qp: %w", err)
	}
	kprobes = append(kprobes, kp)

	kp, err = link.Kprobe("ib_create_qp", t.objs.TraceCreateQp, nil)
	if err != nil {
		return fmt.Errorf("attaching kprobe to ib_create_qp: %w", err)
	}
	kprobes = append(kprobes, kp)

	t.kprobes = kprobes

	// Create ring buffer reader
	reader, err := ringbuf.NewReader(t.objs.RdmaEvents)
	if err != nil {
		return fmt.Errorf("creating ringbuf reader: %w", err)
	}
	t.reader = reader

	// Process events in background
	go t.processEvents()

	return nil
}

// processEvents reads events from the ring buffer and sends them to the channel
func (t *ServiceTracer) processEvents() {
	defer t.reader.Close()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go func() {
		<-t.stopCh
		cancel()
	}()

	for {
		record, err := t.reader.Read()
		if err != nil {
			if ctx.Err() == context.Canceled {
				// Normal termination
				return
			}
			log.Printf("error reading from ringbuf: %v", err)
			continue
		}

		// Convert binary data to RdmaConnTuple struct
		var event RdmaConnTuple
		if err := binary.Read(bytes.NewReader(record.RawSample), binary.LittleEndian, &event); err != nil {
			log.Printf("error parsing ringbuf event: %v", err)
			continue
		}

		// Send event to channel
		select {
		case t.eventCh <- event:
			// Event sent
		case <-ctx.Done():
			return
		}
	}
}

// Events returns the channel of detected RDMA connection events
func (t *ServiceTracer) Events() <-chan RdmaConnTuple {
	return t.eventCh
}

// Stop terminates tracing
func (t *ServiceTracer) Stop() error {
	// Send stop signal
	close(t.stopCh)

	// Detach kprobes
	for _, kp := range t.kprobes {
		kp.Close()
	}

	// Release eBPF resources
	if err := t.objs.Close(); err != nil {
		return fmt.Errorf("closing objects: %w", err)
	}

	return nil
}

// loadRdmaTracingObjects loads the eBPF program.
// This function should be generated by bpf2go tool, but we implement it manually here.
func loadRdmaTracingObjects(objs *rdmaTracingObjects, opts *ebpf.CollectionOptions) error {
	// Read eBPF program bytecode from file
	elfPath := fmt.Sprintf("/sys/fs/bpf/rdma_tracing_%d.elf", os.Getpid())

	// This is a simplified implementation. In practice, use the function generated by bpf2go.
	// This implementation is just a placeholder to avoid compilation errors.
	log.Printf("Note: In production, use the code generated by bpf2go to load eBPF objects")

	return fmt.Errorf("this code is a placeholder. Use bpf2go generated code in actual implementation")
}
